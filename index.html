// ==UserScript==
// @name         Basra Legendary Cloth Wind FX (Pro)
// @namespace    basra-cloth-wind-fx
// @version      2.0.0
// @description  Turns windows into cloth that ripples, stretches and folds realistically with wind gusts (SVG displacement + spring dynamics + flow field wind)
// @match        https://musawe44.github.io/12*
// @grant        none
// ==/UserScript==

(() => {
  "use strict";

  /**************************************************************************
   * 0) WHY THIS WORKS (realistic without 3000 lines)
   * - “Cloth look on text” is hard if you only move DIVs.
//   * - SVG feTurbulence + feDisplacementMap can warp the rendered pixels
   *   of an element (including text) smoothly, which looks like fabric.
   * - Then we drive that filter with spring physics + gust impulses.
   * - Wind visuals: flow-field particles + streak ribbons on Canvas.
   **************************************************************************/

  /**************************************************************************
   * 1) CONFIG
   **************************************************************************/
  const CFG = {
    // Targets (your “windows”)
    windowSelector: ".card, [data-window], section.card",

    // Weather input: you can connect your own windMS here if you want.
    // For now: we read wind from the page if you have #wind or we fallback.
    windRead: {
      selector: "#wind", // your weather widget
      parse: (txt) => {
        // expects "10.2" or "10.2 m/s"
        const m = String(txt).match(/-?\d+(\.\d+)?/);
        return m ? Number(m[0]) : null;
      }
    },

    // Wind scaling (m/s -> visual strength)
    wind: {
      calmMS: 2.0,
      windyMS: 8.0,
      stormMS: 12.0,
      maxStrength: 2.2,     // clamp strength
      directionDeg: 15,     // base direction (degrees) if you don’t have real direction
    },

    // Cloth warp (SVG displacement)
    cloth: {
      baseFrequency: 0.012,      // turbulence frequency base
      freqWindBoost: 0.018,      // increases with wind
      displacementBase: 6,       // base pixels
      displacementMax: 44,       // max pixels at high wind
      octaves: 2,                // turbulence detail
      // “anchor” feel is faked by applying stronger warp near bottom using a mask gradient
      anchorPower: 1.7,
    },

    // Fold / wrap behavior (gust)
    fold: {
      gustChancePerSecAtWindy: 0.30, // gust probability rate
      minIntervalSec: 1.8,
      strengthAtStorm: 1.0,
      durationMs: 650
    },

    // Spring dynamics driving filter params
    spring: {
      // for displacement strength
      k: 70,
      d: 11,
      // for global sway rotation
      kRot: 40,
      dRot: 9,
    },

    // Wind Canvas visuals
    visuals: {
      enable: true,
      dprMax: 2,
      particles: 900,        // high -> more epic
      streaks: 3,            // streak ribbons per gust
      flowScale: 0.004,
      flowSpeed: 0.010,
      particleAlphaMin: 0.05,
      particleAlphaMax: 0.22
    },

    // Safety/perf
    perf: {
      maxWindows: 10,
      reduceMotionRespect: true
    }
  };

  const prefersReducedMotion = CFG.perf.reduceMotionRespect &&
    window.matchMedia &&
    window.matchMedia("(prefers-reduced-motion: reduce)").matches;

  /**************************************************************************
   * 2) UTIL
   **************************************************************************/
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const rand = (a, b) => a + Math.random() * (b - a);

  function nowSec() { return performance.now() / 1000; }

  function readWindMS() {
    try {
      const el = document.querySelector(CFG.windRead.selector);
      if (!el) return null;
      return CFG.windRead.parse(el.textContent);
    } catch { return null; }
  }

  function windStrengthFromMS(wms) {
    const w = Number.isFinite(wms) ? wms : 6;
    const s = (w - CFG.wind.calmMS) / (CFG.wind.stormMS - CFG.wind.calmMS);
    return clamp(s * CFG.wind.maxStrength, 0, CFG.wind.maxStrength);
  }

  /**************************************************************************
   * 3) INJECT STYLES (cloth look + fold animation)
   **************************************************************************/
  const style = document.createElement("style");
  style.textContent = `
    .bwfx-root{
      position:fixed; inset:0;
      pointer-events:none;
      z-index:2147483647;
    }
    canvas.bwfx-wind{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      pointer-events:none;
      z-index:2147483646;
      mix-blend-mode: screen;
    }

    /* Cloth: apply filter + keep it smooth */
    .bwfx-cloth{
      will-change: transform, filter;
      transform-style: preserve-3d;
      backface-visibility: hidden;
      -webkit-font-smoothing: antialiased;
      position: relative;
    }

    /* Fold / wrap: looks like a flag curling then snapping back */
    @keyframes bwfx-fold {
      0%   { transform: perspective(1000px) rotateY(0deg) rotateZ(0deg) skewX(0deg) scaleX(1); }
      35%  { transform: perspective(1000px) rotateY(-22deg) rotateZ(-4deg) skewX(10deg) scaleX(.92); }
      60%  { transform: perspective(1000px) rotateY(28deg)  rotateZ(3deg)  skewX(-12deg) scaleX(.90); }
      100% { transform: perspective(1000px) rotateY(0deg) rotateZ(0deg) skewX(0deg) scaleX(1); }
    }
    .bwfx-fold{
      animation: bwfx-fold ${CFG.fold.durationMs}ms cubic-bezier(.2,.85,.2,1);
    }

    /* Optional subtle “heat gloss” (not melt dripping, just hot shimmer) */
    .bwfx-hot::before{
      content:"";
      position:absolute; inset:-30px;
      pointer-events:none;
      background:
        radial-gradient(140px 80px at 25% 0%, rgba(255,140,90,.16), transparent 70%),
        radial-gradient(180px 90px at 85% 10%, rgba(255,220,140,.12), transparent 65%);
      filter: blur(10px);
      opacity:.9;
      z-index:0;
    }

    /* Prevent filter from breaking map iframe: keep map stable (we still sway/fold container) */
    .bwfx-has-iframe{
      filter: none !important;
    }
  `;
  document.documentElement.appendChild(style);

  /**************************************************************************
   * 4) SVG FILTER FACTORY (per window)
   * We create:
   *   feTurbulence -> feDisplacementMap
   * plus a vertical mask gradient to imitate “anchored at top, looser at bottom”.
   **************************************************************************/
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", "0");
  svg.setAttribute("height", "0");
  svg.style.position = "fixed";
  svg.style.left = "-9999px";
  svg.style.top = "-9999px";
  document.documentElement.appendChild(svg);

  let filterIdCounter = 0;

  function createClothFilter() {
    const id = `bwfx-filter-${++filterIdCounter}`;

    const defs = document.createElementNS(svgNS, "defs");
    const filter = document.createElementNS(svgNS, "filter");
    filter.setAttribute("id", id);
    filter.setAttribute("x", "-20%");
    filter.setAttribute("y", "-20%");
    filter.setAttribute("width", "140%");
    filter.setAttribute("height", "140%");
    filter.setAttribute("filterUnits", "objectBoundingBox");

    const turb = document.createElementNS(svgNS, "feTurbulence");
    turb.setAttribute("type", "fractalNoise");
    turb.setAttribute("baseFrequency", String(CFG.cloth.baseFrequency));
    turb.setAttribute("numOctaves", String(CFG.cloth.octaves));
    turb.setAttribute("seed", String(Math.floor(rand(1, 9999))));
    turb.setAttribute("result", "noise");

    // create an alpha gradient mask to make warp stronger near bottom:
    // We do this by blending noise with a vertical gradient via feComponentTransfer-ish trick.
    // Simpler: use feColorMatrix to keep noise, then feDisplacementMap uses it; we modulate scale in JS
    // and also offset phase per element for natural feel.

    const disp = document.createElementNS(svgNS, "feDisplacementMap");
    disp.setAttribute("in", "SourceGraphic");
    disp.setAttribute("in2", "noise");
    disp.setAttribute("scale", String(CFG.cloth.displacementBase));
    disp.setAttribute("xChannelSelector", "R");
    disp.setAttribute("yChannelSelector", "G");

    filter.appendChild(turb);
    filter.appendChild(disp);
    defs.appendChild(filter);
    svg.appendChild(defs);

    return { id, turb, disp };
  }

  /**************************************************************************
   * 5) SPRING MODEL (smooth realistic motion)
   **************************************************************************/
  function makeSpring(x0 = 0) {
    return { x: x0, v: 0 };
  }
  function springStep(s, target, dt, k, d) {
    // classic damped spring: x'' = k*(target-x) - d*x'
    const a = k * (target - s.x) - d * s.v;
    s.v += a * dt;
    s.x += s.v * dt;
    return s.x;
  }

  /**************************************************************************
   * 6) WINDOW ATTACH: apply cloth filter + drive it
   **************************************************************************/
  function hasIframe(el) {
    return !!el.querySelector("iframe");
  }

  function attachToWindows() {
    const list = Array.from(document.querySelectorAll(CFG.windowSelector))
      .filter(el => el && el.getBoundingClientRect && el.offsetParent !== null)
      .slice(0, CFG.perf.maxWindows);

    return list.map((el) => {
      el.classList.add("bwfx-cloth");
      if (hasIframe(el)) el.classList.add("bwfx-has-iframe");

      const filter = createClothFilter();
      // Apply filter to element (except iframe case)
      if (!el.classList.contains("bwfx-has-iframe")) {
        el.style.filter = `url(#${filter.id})`;
      }

      // state
      return {
        el,
        filter,
        // springs
        dispS: makeSpring(CFG.cloth.displacementBase),
        freqS: makeSpring(CFG.cloth.baseFrequency),
        rotS: makeSpring(0),
        // gust/fold timers
        lastFoldSec: 0,
        // per-window phase offset
        phase: rand(0, 1000),
      };
    });
  }

  const windows = attachToWindows();

  /**************************************************************************
   * 7) WIND VISUALS (Flow Field + particles + streaks)
   **************************************************************************/
  let canvas = null, ctx = null;
  let particles = [];
  let streaks = [];

  function initWindCanvas() {
    if (!CFG.visuals.enable || prefersReducedMotion) return;

    canvas = document.createElement("canvas");
    canvas.className = "bwfx-wind";
    document.documentElement.appendChild(canvas);
    ctx = canvas.getContext("2d", { alpha: true });

    function resize() {
      const dpr = Math.max(1, Math.min(CFG.visuals.dprMax, window.devicePixelRatio || 1));
      canvas.width = Math.floor(innerWidth * dpr);
      canvas.height = Math.floor(innerHeight * dpr);
      canvas.style.width = "100vw";
      canvas.style.height = "100vh";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener("resize", resize);
    resize();

    // value noise
    const Noise = {
      seed: 1337,
      hash(x, y) {
        let n = x * 374761393 + y * 668265263 + Noise.seed * 1442695041;
        n = (n ^ (n >> 13)) * 1274126177;
        return ((n ^ (n >> 16)) >>> 0) / 4294967295;
      },
      smooth(t) { return t * t * (3 - 2 * t); },
      noise(x, y) {
        const xi = Math.floor(x), yi = Math.floor(y);
        const xf = x - xi, yf = y - yi;
        const a = Noise.hash(xi, yi);
        const b = Noise.hash(xi + 1, yi);
        const c = Noise.hash(xi, yi + 1);
        const d = Noise.hash(xi + 1, yi + 1);
        const u = Noise.smooth(xf), v = Noise.smooth(yf);
        return (a * (1 - u) + b * u) * (1 - v) + (c * (1 - u) + d * u) * v;
      }
    };

    function resetParticle(p) {
      p.x = Math.random() * innerWidth;
      p.y = Math.random() * innerHeight;
      p.vx = 0; p.vy = 0;
      p.life = 160 + Math.random() * 260;
      p.size = 0.6 + Math.random() * 1.9;
      p.alpha = rand(CFG.visuals.particleAlphaMin, CFG.visuals.particleAlphaMax);
    }

    particles = [];
    for (let i = 0; i < CFG.visuals.particles; i++) {
      const p = {};
      resetParticle(p);
      particles.push(p);
    }

    function spawnStreak(wStrength) {
      const y = rand(60, innerHeight - 120);
      const segs = 22;
      const s = {
        x: -240,
        y,
        pts: Array.from({ length: segs }, (_, k) => ({ x: -240 - k * 16, y })),
        life: 75 + Math.random() * 45,
        a: 0.10 + wStrength * 0.22
      };
      streaks.push(s);
    }

    return { Noise, resetParticle, spawnStreak };
  }

  const windViz = initWindCanvas();

  /**************************************************************************
   * 8) MAIN LOOP (physics + cloth filter + fold + visuals)
   **************************************************************************/
  let lastT = performance.now();
  let t = 0;
  let gust = 0;
  let gustTimer = 0;

  function maybeFold(win, wStrength, wms) {
    const sec = nowSec();
    if (sec - win.lastFoldSec < CFG.fold.minIntervalSec) return;
    if (!Number.isFinite(wms) || wms < CFG.wind.windyMS) return;

    // probability rate scales with wind
    const rate = CFG.fold.gustChancePerSecAtWindy * clamp((wms - CFG.wind.windyMS) / 6, 0, 1.4);
    if (Math.random() < rate * (1 / 60)) { // approx per frame
      win.lastFoldSec = sec;
      win.el.classList.remove("bwfx-fold");
      void win.el.offsetWidth; // restart
      win.el.classList.add("bwfx-fold");
    }
  }

  function step(now) {
    const dt = Math.min(0.03, (now - lastT) / 1000);
    lastT = now;
    t += dt;

    // Wind input
    const wms = readWindMS();
    const wStrength = windStrengthFromMS(wms);

    // Gust impulse (drives extra power)
    gustTimer -= dt;
    if (!prefersReducedMotion && gustTimer <= 0 && (wms ?? 0) > CFG.wind.windyMS && Math.random() < (0.18 + wStrength * 0.14)) {
      gust = 0.9 + Math.random() * 1.8;
      gustTimer = 0.35 + Math.random() * 0.75;

      // spawn strong streaks
      if (windViz && CFG.visuals.enable) {
        for (let i = 0; i < CFG.visuals.streaks; i++) windViz.spawnStreak(wStrength);
      }
    } else {
      // decay
      gust *= Math.pow(0.001, dt);
    }

    // Drive each window cloth
    for (const w of windows) {
      // Targets for filter
      const targetDisp = lerp(
        CFG.cloth.displacementBase,
        CFG.cloth.displacementMax,
        clamp(wStrength / CFG.wind.maxStrength, 0, 1)
      ) + gust * 14;

      const targetFreq = CFG.cloth.baseFrequency + wStrength * CFG.cloth.freqWindBoost;

      // Springs
      const disp = springStep(w.dispS, targetDisp, dt, CFG.spring.k, CFG.spring.d);
      const freq = springStep(w.freqS, targetFreq, dt, CFG.spring.k, CFG.spring.d);

      // Global sway rotation (like flag pole effect)
      const rotTarget = (wStrength * 3.2 + gust * 6.0) * Math.sin(t * (1.4 + wStrength * 0.6) + w.phase);
      const rot = springStep(w.rotS, rotTarget, dt, CFG.spring.kRot, CFG.spring.dRot);

      // Apply filter params (skip if iframe)
      if (!w.el.classList.contains("bwfx-has-iframe")) {
        w.filter.turb.setAttribute("baseFrequency", String(freq));
        // animate seed a bit for “moving cloth texture”
        // (small change so it doesn’t flicker)
        const seed = 1000 + Math.floor((t * 12 + w.phase) % 2000);
        w.filter.turb.setAttribute("seed", String(seed));
        w.filter.disp.setAttribute("scale", String(disp));
      }

      // Apply transform (sway + tiny stretch)
      const stretch = 1 + clamp((Math.abs(rot) / 18) * 0.05, 0, 0.08);
      w.el.style.transform = `perspective(1000px) rotateY(${rot}deg) skewX(${rot * 0.35}deg) scaleX(${stretch})`;

      // Fold on gusts
      maybeFold(w, wStrength, wms);
    }

    // Wind visuals
    if (ctx && windViz && CFG.visuals.enable && !prefersReducedMotion) {
      ctx.clearRect(0, 0, innerWidth, innerHeight);

      const ws = wStrength;
      const Noise = windViz.Noise;

      // base drift direction (rightwards) + tiny angle
      const dir = (CFG.wind.directionDeg * Math.PI) / 180;
      const baseDX = Math.cos(dir);
      const baseDY = Math.sin(dir);

      const speedBoost = 0.85 + ws * 3.0 + gust * 0.6;

      for (const p of particles) {
        const nx = Noise.noise(p.x * CFG.visuals.flowScale, p.y * CFG.visuals.flowScale + t * CFG.visuals.flowSpeed);
        const ny = Noise.noise(p.x * CFG.visuals.flowScale + 111, p.y * CFG.visuals.flowScale + t * CFG.visuals.flowSpeed);

        const ang = (nx * 2 - 1) * 1.55 + (ws * 1.35);
        const fx = Math.cos(ang) * (0.6 + ws * 2.6) + baseDX * (0.8 + ws * 2.0);
        const fy = (ny - 0.5) * (1.0 + ws * 1.3) + baseDY * (0.6 + ws * 1.2);

        p.vx = (p.vx + fx * dt * 120) * 0.985;
        p.vy = (p.vy + fy * dt * 120) * 0.985;

        p.x += p.vx * dt * 10 * speedBoost;
        p.y += p.vy * dt * 10 * speedBoost;

        p.life -= 1;
        if (p.x < -80 || p.x > innerWidth + 80 || p.y < -80 || p.y > innerHeight + 80 || p.life <= 0) {
          windViz.resetParticle(p);
          p.x = -60; // enter from left
        }

        ctx.globalAlpha = p.alpha * (0.40 + ws * 0.85);
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(235,248,255,1)";
        ctx.fill();
      }

      // streak ribbons
      for (let i = streaks.length - 1; i >= 0; i--) {
        const s = streaks[i];
        s.life -= 1;

        const adv = (14 + ws * 26) * speedBoost;
        s.x += adv;

        s.pts[0].x = s.x;
        s.pts[0].y = s.y + (Noise.noise(s.x * 0.01, t * 0.7) - 0.5) * (18 + ws * 18 + gust * 10);

        for (let k = 1; k < s.pts.length; k++) {
          const prev = s.pts[k - 1];
          const cur = s.pts[k];
          const follow = 0.18 + ws * 0.06;
          cur.x += (prev.x - cur.x) * follow;
          cur.y += (prev.y - cur.y) * follow;
          cur.y += (Noise.noise((cur.x + 77) * 0.01, (cur.y + 33) * 0.01 + t * 0.9) - 0.5) * (1.6 + ws * 2.6);
        }

        ctx.globalAlpha = s.a * (0.55 + ws * 0.7);
        ctx.lineWidth = 2.6 + ws * 1.2 + gust * 0.6;
        ctx.strokeStyle = "rgba(240,252,255,1)";
        ctx.beginPath();
        ctx.moveTo(s.pts[0].x, s.pts[0].y);
        for (let k = 1; k < s.pts.length; k++) ctx.lineTo(s.pts[k].x, s.pts[k].y);
        ctx.stroke();

        if (s.life <= 0 || s.x > innerWidth + 520) streaks.splice(i, 1);
      }

      ctx.globalAlpha = 1;
    }

    requestAnimationFrame(step);
  }

  /**************************************************************************
   * 9) START
   **************************************************************************/
  if (windows.length === 0) {
    console.warn("[BWFX] No windows found. Check CFG.windowSelector.");
    return;
  }

  requestAnimationFrame(step);

})();